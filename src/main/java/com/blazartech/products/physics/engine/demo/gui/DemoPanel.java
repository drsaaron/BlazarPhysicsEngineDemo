/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * DemoPanel.java
 *
 * Created on Oct 7, 2010, 3:13:23 PM
 */

package com.blazartech.products.physics.engine.demo.gui;

import com.blazartech.products.physics.engine.Body;
import com.blazartech.products.physics.engine.Vector2D;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.util.Collection;
import javax.swing.JPanel;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 *
 * @author aar1069
 */
public class DemoPanel extends JPanel {

    private static Logger logger = LoggerFactory.getLogger(DemoPanel.class);

    /** Creates new form DemoPanel */
    public DemoPanel() {
        initComponents();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    private Collection<Body> bodies;

    /**
     * Get the value of bodies
     *
     * @return the value of bodies
     */
    public Collection<Body> getBodies() {
        return bodies;
    }

    /**
     * Set the value of bodies
     *
     * @param bodies new value of bodies
     */
    public void setBodies(Collection<Body> bodies) {
        this.bodies = bodies;
    }

    private int circleSize = 10;

    /**
     * Get the value of circleSize
     *
     * @return the value of circleSize
     */
    public int getCircleSize() {
        return circleSize;
    }

    /**
     * Set the value of circleSize
     *
     * @param circleSize new value of circleSize
     */
    public void setCircleSize(int circleSize) {
        this.circleSize = circleSize;
    }

    private double scaleFactor = 1.f;

    /**
     * Get the value of scaleFactor
     *
     * @return the value of scaleFactor
     */
    public double getScaleFactor() {
        return scaleFactor;
    }

    /**
     * Set the value of scaleFactor
     *
     * @param scaleFactor new value of scaleFactor
     */
    public void setScaleFactor(double scaleFactor) {
        this.scaleFactor = scaleFactor;
    }

    private boolean clearBeforePaint = false;

    /**
     * Get the value of clearBeforePaint
     *
     * @return the value of clearBeforePaint
     */
    public boolean isClearBeforePaint() {
        return clearBeforePaint;
    }

    /**
     * Set the value of clearBeforePaint
     *
     * @param clearBeforePaint new value of clearBeforePaint
     */
    public void setClearBeforePaint(boolean clearBeforePaint) {
        this.clearBeforePaint = clearBeforePaint;
    }

    private static Color[] colorSequence = { Color.BLACK, Color.BLUE, Color.CYAN, Color.DARK_GRAY };

    public int getRelativePositionX(Vector2D position) {
        return (int) (getSize().getWidth() / 2) + (int) (position.getX() / getScaleFactor());
    }
    
    public int getRelativePositionY(Vector2D position) {
        return (int) (getSize().getHeight() / 2) + (int) (position.getY() / getScaleFactor());
    }
    
    @Override
    public void paint(Graphics g) {

        // determine the origin.
        Dimension size = getSize();
        if (isClearBeforePaint()) {
            g.clearRect(0, 0, (int) size.getWidth(), (int) size.getHeight());
        }
        logger.info("component size = " + size);
        int originX = (int) (size.getWidth() / 2);
        int originY = (int) (size.getHeight() / 2);
        g.drawString("+", originX, originY);
        
        // some other useful positions
        Vector2D[] positions = new Vector2D[] { 
            new Vector2D(500, 0),
            new Vector2D(0, 500),
            new Vector2D(-500, 0),
            new Vector2D(0, -500)
        };
        for (Vector2D p : positions) {
            g.drawString("C", getRelativePositionX(p), getRelativePositionY(p));
        }
        
        // right now all bodies are point masses, so just draw circles.
        int colorNumber = 0;
        for (Body b : getBodies()) {
            int positionX = getRelativePositionX(b.getState().getPosition());
            int positionY = getRelativePositionY(b.getState().getPosition());
            logger.info("drawing body at " + b.getState().getPosition() + " at coordinates (" + positionX + ", " + positionY + ")");

            Color color;
            if (colorNumber > colorSequence.length) {
                color = Color.YELLOW;
            } else {
                color = colorSequence[colorNumber++];
            }
            g.setColor(color);
            g.fillOval(positionX, positionY, getCircleSize(), getCircleSize());
        }
    }


}
